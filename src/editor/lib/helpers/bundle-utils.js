// Generated by CoffeeScript 1.12.7
var uuid;

uuid = require("node-uuid");

module.exports = {
  fixAllRefs: function(resources, subs) {
    var fixed, i, j, len, resource;
    fixed = [];
    for (i = j = 0, len = resources.length; j < len; i = ++j) {
      resource = resources[i];
      if (resource.toJS) {
        resource = resource.toJS();
      }
      this.fixRefs(resource, subs);
      fixed.push(resource);
    }
    return fixed;
  },
  fixRefs: function(resource, subs) {
    var _notDate, _walkNode, count;
    count = 0;
    _notDate = function(value) {
      return !(value instanceof Date);
    };
    _walkNode = function(node) {
      var j, k, len, results, results1, sub, v;
      if (node instanceof Array) {
        results = [];
        for (j = 0, len = node.length; j < len; j++) {
          v = node[j];
          results.push(_walkNode(v));
        }
        return results;
      } else if (typeof node === "object" && _notDate(node)) {
        results1 = [];
        for (k in node) {
          v = node[k];
          if (k !== "reference") {
            results1.push(_walkNode(v));
          } else if (v) {
            results1.push((function() {
              var l, len1, results2;
              results2 = [];
              for (l = 0, len1 = subs.length; l < len1; l++) {
                sub = subs[l];
                if (!(v && sub.from && v.toUpperCase() === sub.from.toUpperCase())) {
                  continue;
                }
                if (sub.to) {
                  node[k] = sub.to;
                }
                results2.push(count += 1);
              }
              return results2;
            })());
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }
    };
    _walkNode(resource);
    return count;
  },
  countRefs: function(resources, ref) {
    var count, hasRefs, j, len, resource;
    count = 0;
    for (j = 0, len = resources.length; j < len; j++) {
      resource = resources[j];
      hasRefs = this.fixRefs(resource, [
        {
          from: ref
        }
      ]);
      if (hasRefs !== 0) {
        count += 1;
      }
    }
    return count;
  },
  buildFredId: function(nextId) {
    return "FRED-" + nextId;
  },
  findNextId: function(entries) {
    var entry, id, j, len, matches, maxId, ref1;
    maxId = 1;
    for (j = 0, len = entries.length; j < len; j++) {
      entry = entries[j];
      if (id = ((ref1 = entry.resource) != null ? ref1.id : void 0) || entry.id) {
        if (matches = id.match(/^fred\-(\d+)/i)) {
          maxId = Math.max(maxId, parseInt(matches[1]) + 1);
        }
      }
    }
    return maxId;
  },
  parseBundle: function(bundle, clearInternalIds) {
    var entry, entryPos, fromId, idSubs, j, l, len, len1, ref1, ref2, resourceType, resources, toId;
    idSubs = [];
    entryPos = this.findNextId(bundle.entry);
    ref1 = bundle.entry;
    for (j = 0, len = ref1.length; j < len; j++) {
      entry = ref1[j];
      if ((entry.fullUrl && /^urn:uuid:/.test(entry.fullUrl)) || !entry.resource.id || clearInternalIds) {
        resourceType = entry.resource.resourceType;
        fromId = entry.resource.id || entry.fullUrl;
        entry.resource.id = toId = this.buildFredId(entryPos);
        idSubs.push({
          from: fromId,
          to: resourceType + "/" + toId
        });
        entryPos++;
      }
    }
    resources = [];
    ref2 = bundle.entry;
    for (l = 0, len1 = ref2.length; l < len1; l++) {
      entry = ref2[l];
      this.fixRefs(entry.resource, idSubs);
      resources.push(entry.resource);
    }
    return resources;
  },
  generateBundle: function(resources, splicePos, spliceData) {
    var bundle, entries, entry, fromId, fullUrl, idSubs, j, l, len, len1, request, resource, toId;
    if (resources == null) {
      resources = [];
    }
    if (splicePos == null) {
      splicePos = null;
    }
    if (splicePos !== null) {
      resources = resources.splice(splicePos, 1, spliceData);
    }
    idSubs = [];
    entries = [];
    for (j = 0, len = resources.length; j < len; j++) {
      resource = resources[j];
      if (resource.toJS) {
        resource = resource.toJS();
      }
      if (resource.id && !/^[Ff][Rr][Ee][Dd]\-\d+/.test(resource.id)) {
        fullUrl = resource.resourceType + "/" + resource.id;
        request = {
          method: "PUT",
          url: fullUrl
        };
      } else {
        fullUrl = "urn:uuid:" + (uuid.v4());
        request = {
          method: "POST",
          url: resource.resourceType
        };
        if (resource.id) {
          fromId = resource.resourceType + "/" + resource.id;
          toId = fullUrl;
          idSubs.push({
            from: fromId,
            to: toId
          });
          delete resource.id;
        }
      }
      entries.push({
        fullUrl: fullUrl,
        request: request,
        resource: resource
      });
    }
    for (l = 0, len1 = entries.length; l < len1; l++) {
      entry = entries[l];
      this.fixRefs(entry.resource, idSubs);
    }
    return bundle = {
      resourceType: "Bundle",
      type: "transaction",
      meta: {
        lastUpdated: (new Date()).toISOString(),
        fhir_comments: ["Generated by FRED"]
      },
      entry: entries
    };
  }
};
